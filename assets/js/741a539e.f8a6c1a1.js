"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[475],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),m=p(t),h=r,u=m["".concat(s,".").concat(h)]||m[h]||d[h]||o;return t?a.createElement(u,c(c({ref:n},l),{},{components:t})):a.createElement(u,c({ref:n},l))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,c=new Array(o);c[0]=h;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[m]="string"==typeof e?e:r,c[1]=i;for(var p=2;p<o;p++)c[p]=t[p];return a.createElement.apply(null,c)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},1159:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const o={},c="Schemas",i={unversionedId:"user-guide/schemas",id:"user-guide/schemas",title:"Schemas",description:"The primary interface for cavro is the cavro.Schema class.  These are constructed from an avro schema definition:",source:"@site/docs/user-guide/schemas.md",sourceDirName:"user-guide",slug:"/user-guide/schemas",permalink:"/docs/user-guide/schemas",draft:!1,editUrl:"https://github.com/stestagg/cavro/tree/main/doc/docs/user-guide/schemas.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Record Types",permalink:"/docs/user-guide/records"},next:{title:"API Reference",permalink:"/docs/api"}},s={},p=[{value:"Constructing Schemas",id:"constructing-schemas",level:2},{value:"Options",id:"options",level:2},{value:"Encoding / Decoding values",id:"encoding--decoding-values",level:2},{value:"Schema dict, Schema String &amp; Canonical form",id:"schema-dict-schema-string--canonical-form",level:2}],l={toc:p},m="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"schemas"},"Schemas"),(0,r.kt)("p",null,"The primary interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"cavro")," is the ",(0,r.kt)("a",{parentName:"p",href:"/docs/api#class-schema"},"cavro.Schema")," class.  These are constructed from an avro schema definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'schema = cavro.Schema(\'{"type": "int"}\')\nprint(schema)\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<cavro.Schema object at 0x11585d990>\n")),(0,r.kt)("p",null,"Schemas are actually convenience wrappers around the underlying ",(0,r.kt)("a",{parentName:"p",href:"/docs/api#class-avrotype"},"avro types")," that do the heavy-lifting of encoding/decoding."),(0,r.kt)("h2",{id:"constructing-schemas"},"Constructing Schemas"),(0,r.kt)("p",null,"Schemas can be created from a JSON string representing the schema, or from a python object that matches a JSON schema."),(0,r.kt)("p",null,"Sometimes the expected behaviour can be ambiguous, so there is a 'parse_json' argument that can disable json parsing.  The following are all equivalent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"print(cavro.Schema('{\"type\": \"int\"}').schema_str)\nprint(cavro.Schema('\"int\"').schema_str)\nprint(cavro.Schema({'type': 'int'}).schema_str)\nprint(cavro.Schema('int', parse_json=False).schema_str)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'"int"\n"int"\n"int"\n"int"\n')),(0,r.kt)("p",null,"Whereas this will not work, because cavro tries to parse 'int' as a JSON string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"try:\n    cavro.Schema('int')\nexcept Exception as e:\n    print(e)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Expecting value: line 1 column 1 (char 0)\n")),(0,r.kt)("h2",{id:"options"},"Options"),(0,r.kt)("p",null,"How a schema behaves can be controlled through ",(0,r.kt)("a",{parentName:"p",href:"/docs/api#class-options"},"Options"),". Options can be passed to a schema, either using the ",(0,r.kt)("inlineCode",{parentName:"p"},"options=")," argument, or via kwargs the the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema.__init__")," that match the fields of ",(0,r.kt)("inlineCode",{parentName:"p"},"Options"),"."),(0,r.kt)("p",null,"If no options are provided, then the schema uses ",(0,r.kt)("inlineCode",{parentName:"p"},"cavro.DEFAULT_OPTIONS")," which provides reasonable defaults."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"schema0 = cavro.Schema('\"int\"')\nprint('0: ', schema0.options.coerce_values_to_int)\n\nschema1 = cavro.Schema('\"int\"', coerce_values_to_int=True)\nprint('1: ', schema1.options.coerce_values_to_int)\n\nschema2 = cavro.Schema('\"int\"', coerce_values_to_int=False)\nprint('2: ', schema2.options.coerce_values_to_int)\n\nschema3 = cavro.Schema('\"int\"', options=cavro.DEFAULT_OPTIONS.replace(coerce_values_to_int=True))\nprint('3: ', schema3.options.coerce_values_to_int)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0:  False\n1:  True\n2:  False\n3:  True\n")),(0,r.kt)("p",null,"The various flags and what they mean are described in ",(0,r.kt)("a",{parentName:"p",href:"/docs/api#class-options"},"The Api reference"),", and ",(0,r.kt)("a",{parentName:"p",href:"/docs/user-guide/options"},"the options user guide")),(0,r.kt)("h2",{id:"encoding--decoding-values"},"Encoding / Decoding values"),(0,r.kt)("p",null,"Encoding and decoding values is done using the ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_encode"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"binary_decode"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"json_encode"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"json_decode")," methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"print(schema.binary_encode(3))\nprint(schema.binary_decode(b'\\x00\\x06'))\nprint(schema.json_encode(3))\nprint(schema.json_decode('{\"int\": 3}'))\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"b'\\x00\\x06'\n3\n{\"int\": 3}\n3\n")),(0,r.kt)("h2",{id:"schema-dict-schema-string--canonical-form"},"Schema dict, Schema String & Canonical form"),(0,r.kt)("p",null,"Unlike other libraries, ",(0,r.kt)("inlineCode",{parentName:"p"},"cavro")," does not retain the original source used to construct a schema.  Standard representations of the avro schema definitions can be retrived from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Schema")," using several properties (None of these are guaranteed to be identical to the original source)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Schema.schema")," - A python object that represents the schema definition"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Schema.schema_str")," - JSON encoded version of the above"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Schema.canonical_form")," - The ",(0,r.kt)("a",{parentName:"li",href:"https://avro.apache.org/docs/1.11.1/specification/#parsing-canonical-form-for-schemas"},"Parsing Canonical Form")," of the schema")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'schema = cavro.Schema(\'["int", {"type": "long"}, {"fields": [{"name": "a", "type": "A"}], "type": "record", "name": "A", "namespace": "x"}]\')\n\nschema.schema\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"['int',\n 'long',\n {'namespace': 'x',\n  'name': 'A',\n  'fields': [{'name': 'a', 'type': 'x.A'}],\n  'type': 'record'}]\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"print(schema.schema_str)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[\n  "int",\n  "long",\n  {\n    "namespace": "x",\n    "name": "A",\n    "fields": [\n      {\n        "name": "a",\n        "type": "x.A"\n      }\n    ],\n    "type": "record"\n  }\n]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"schema.canonical_form\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'\'["int","long",{"name":"x.A","type":"record","fields":[{"name":"a","type":"x.A"}]}]\'\n')))}d.isMDXComponent=!0}}]);